import {
  computePosition,
  flip,
  offset
} from "./chunk-QF55BDXM.js";
import {
  $ctx,
  $prose
} from "./chunk-26DJ723H.js";
import {
  require_lodash
} from "./chunk-YQD7567M.js";
import {
  Plugin,
  PluginKey,
  TextSelection,
  findParentNode,
  posToDOMRect
} from "./chunk-RMA7BMCH.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __toESM
} from "./chunk-DWA4UIM3.js";

// ../node_modules/@milkdown/plugin-slash/lib/index.js
var import_lodash = __toESM(require_lodash());
function slashFactory(id) {
  const slashSpec = $ctx(
    {},
    `${id}_SLASH_SPEC`
  );
  const slashPlugin = $prose((ctx) => {
    const spec = ctx.get(slashSpec.key);
    return new Plugin({
      key: new PluginKey(`${id}_SLASH`),
      ...spec
    });
  });
  const result = [slashSpec, slashPlugin];
  result.key = slashSpec.key;
  result.pluginKey = slashPlugin.key;
  slashSpec.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${id}`
  };
  slashPlugin.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${id}`
  };
  return result;
}
var _initialized, _middleware, _floatingUIOptions, _root, _debounce, _trigger, _shouldShow, _updater, _offset, _onUpdate, _SlashProvider_instances, _shouldShow_fn;
var SlashProvider = class {
  constructor(options) {
    __privateAdd(this, _SlashProvider_instances);
    __privateAdd(this, _initialized);
    /// @internal
    __privateAdd(this, _middleware);
    /// @internal
    __privateAdd(this, _floatingUIOptions);
    /// @internal
    __privateAdd(this, _root);
    /// @internal
    __privateAdd(this, _debounce);
    /// @internal
    __privateAdd(this, _trigger);
    /// @internal
    __privateAdd(this, _shouldShow);
    /// @internal
    __privateAdd(this, _updater);
    /// The offset to get the block. Default is 0.
    __privateAdd(this, _offset);
    __privateAdd(this, _onUpdate);
    __privateSet(this, _initialized, false);
    this.onShow = () => {
    };
    this.onHide = () => {
    };
    __privateSet(this, _onUpdate, (view, prevState) => {
      const { state, composing } = view;
      const { selection, doc } = state;
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const isSame = prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection);
      if (!__privateGet(this, _initialized)) {
        const root = __privateGet(this, _root) ?? view.dom.parentElement ?? document.body;
        root.appendChild(this.element);
        __privateSet(this, _initialized, true);
      }
      if (composing || isSame) return;
      if (!__privateGet(this, _shouldShow).call(this, view, prevState)) {
        this.hide();
        return;
      }
      const virtualEl = {
        getBoundingClientRect: () => posToDOMRect(view, from, to)
      };
      computePosition(virtualEl, this.element, {
        placement: "bottom-start",
        middleware: [flip(), offset(__privateGet(this, _offset)), ...__privateGet(this, _middleware)],
        ...__privateGet(this, _floatingUIOptions)
      }).then(({ x, y }) => {
        Object.assign(this.element.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      }).catch(console.error);
      this.show();
    });
    this.update = (view, prevState) => {
      __privateGet(this, _updater).call(this, view, prevState);
    };
    this.getContent = (view, matchNode = (node) => node.type.name === "paragraph") => {
      const { selection } = view.state;
      const { empty, $from } = selection;
      const isTextBlock = view.state.selection instanceof TextSelection;
      if (typeof document === "undefined") return;
      const isSlashChildren = this.element.contains(document.activeElement);
      const notHasFocus = !view.hasFocus() && !isSlashChildren;
      const isReadonly = !view.editable;
      const paragraph = findParentNode(matchNode)(view.state.selection);
      const isNotInParagraph = !paragraph;
      if (notHasFocus || isReadonly || !empty || !isTextBlock || isNotInParagraph)
        return;
      return $from.parent.textBetween(
        Math.max(0, $from.parentOffset - 500),
        $from.parentOffset,
        void 0,
        "ï¿¼"
      );
    };
    this.destroy = () => {
      __privateGet(this, _updater).cancel();
    };
    this.show = () => {
      this.element.dataset.show = "true";
      this.onShow();
    };
    this.hide = () => {
      this.element.dataset.show = "false";
      this.onHide();
    };
    this.element = options.content;
    __privateSet(this, _debounce, options.debounce ?? 200);
    __privateSet(this, _shouldShow, options.shouldShow ?? __privateMethod(this, _SlashProvider_instances, _shouldShow_fn));
    __privateSet(this, _trigger, options.trigger ?? "/");
    __privateSet(this, _offset, options.offset);
    __privateSet(this, _middleware, options.middleware ?? []);
    __privateSet(this, _floatingUIOptions, options.floatingUIOptions ?? {});
    __privateSet(this, _root, options.root);
    __privateSet(this, _updater, (0, import_lodash.default)(__privateGet(this, _onUpdate), __privateGet(this, _debounce)));
  }
};
_initialized = new WeakMap();
_middleware = new WeakMap();
_floatingUIOptions = new WeakMap();
_root = new WeakMap();
_debounce = new WeakMap();
_trigger = new WeakMap();
_shouldShow = new WeakMap();
_updater = new WeakMap();
_offset = new WeakMap();
_onUpdate = new WeakMap();
_SlashProvider_instances = new WeakSet();
/// @internal
_shouldShow_fn = function(view) {
  const currentTextBlockContent = this.getContent(view);
  if (!currentTextBlockContent) return false;
  const target = currentTextBlockContent.at(-1);
  if (!target) return false;
  return Array.isArray(__privateGet(this, _trigger)) ? __privateGet(this, _trigger).includes(target) : __privateGet(this, _trigger) === target;
};
export {
  SlashProvider,
  slashFactory
};
//# sourceMappingURL=@milkdown_plugin-slash.js.map
