import {
  computePosition,
  flip,
  offset,
  shift
} from "./chunk-QF55BDXM.js";
import {
  $ctx,
  $prose
} from "./chunk-26DJ723H.js";
import {
  Plugin,
  PluginKey,
  TextSelection,
  posToDOMRect
} from "./chunk-RMA7BMCH.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __toESM
} from "./chunk-DWA4UIM3.js";

// ../node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "../node_modules/lodash.throttle/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = throttle2;
  }
});

// ../node_modules/@milkdown/plugin-tooltip/lib/index.js
var import_lodash = __toESM(require_lodash());
var _debounce, _shouldShow, _middleware, _floatingUIOptions, _root, _initialized, _offset, _shift, _updater, _onUpdate, _TooltipProvider_instances, _shouldShow_fn;
var TooltipProvider = class {
  constructor(options) {
    __privateAdd(this, _TooltipProvider_instances);
    /// @internal
    __privateAdd(this, _debounce);
    /// @internal
    __privateAdd(this, _shouldShow);
    /// @internal
    __privateAdd(this, _middleware);
    /// @internal
    __privateAdd(this, _floatingUIOptions);
    /// @internal
    __privateAdd(this, _root);
    __privateAdd(this, _initialized);
    /// @internal
    __privateAdd(this, _offset);
    /// @internal
    __privateAdd(this, _shift);
    /// @internal
    __privateAdd(this, _updater);
    __privateAdd(this, _onUpdate);
    __privateSet(this, _initialized, false);
    this.onShow = () => {
    };
    this.onHide = () => {
    };
    __privateSet(this, _onUpdate, (view, prevState) => {
      const { state, composing } = view;
      const { selection, doc } = state;
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const isSame = prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection);
      if (!__privateGet(this, _initialized)) {
        const root = __privateGet(this, _root) ?? view.dom.parentElement ?? document.body;
        root.appendChild(this.element);
        __privateSet(this, _initialized, true);
      }
      if (composing || isSame) return;
      if (!__privateGet(this, _shouldShow).call(this, view, prevState)) {
        this.hide();
        return;
      }
      const virtualEl = {
        getBoundingClientRect: () => posToDOMRect(view, from, to)
      };
      computePosition(virtualEl, this.element, {
        placement: __privateGet(this, _floatingUIOptions).placement ?? "top",
        middleware: [
          flip(),
          offset(__privateGet(this, _offset)),
          shift(__privateGet(this, _shift)),
          ...__privateGet(this, _middleware)
        ]
      }).then(({ x, y }) => {
        Object.assign(this.element.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      }).catch(console.error);
      this.show();
    });
    this.update = (view, prevState) => {
      __privateGet(this, _updater).call(this, view, prevState);
    };
    this.destroy = () => {
      __privateGet(this, _updater).cancel();
    };
    this.show = (virtualElement) => {
      this.element.dataset.show = "true";
      if (virtualElement) {
        computePosition(virtualElement, this.element, {
          placement: "top",
          middleware: [
            flip(),
            offset(__privateGet(this, _offset)),
            shift(__privateGet(this, _shift)),
            ...__privateGet(this, _middleware)
          ],
          ...__privateGet(this, _floatingUIOptions)
        }).then(({ x, y }) => {
          Object.assign(this.element.style, {
            left: `${x}px`,
            top: `${y}px`
          });
        }).catch(console.error);
      }
      this.onShow();
    };
    this.hide = () => {
      if (this.element.dataset.show === "false") return;
      this.element.dataset.show = "false";
      this.onHide();
    };
    this.element = options.content;
    __privateSet(this, _debounce, options.debounce ?? 200);
    __privateSet(this, _shouldShow, options.shouldShow ?? __privateMethod(this, _TooltipProvider_instances, _shouldShow_fn));
    __privateSet(this, _offset, options.offset);
    __privateSet(this, _shift, options.shift);
    __privateSet(this, _middleware, options.middleware ?? []);
    __privateSet(this, _floatingUIOptions, options.floatingUIOptions ?? {});
    __privateSet(this, _root, options.root);
    this.element.dataset.show = "false";
    __privateSet(this, _updater, (0, import_lodash.default)(__privateGet(this, _onUpdate), __privateGet(this, _debounce)));
  }
};
_debounce = new WeakMap();
_shouldShow = new WeakMap();
_middleware = new WeakMap();
_floatingUIOptions = new WeakMap();
_root = new WeakMap();
_initialized = new WeakMap();
_offset = new WeakMap();
_shift = new WeakMap();
_updater = new WeakMap();
_onUpdate = new WeakMap();
_TooltipProvider_instances = new WeakSet();
/// @internal
_shouldShow_fn = function(view) {
  const { doc, selection } = view.state;
  const { empty, from, to } = selection;
  const isEmptyTextBlock = !doc.textBetween(from, to).length && view.state.selection instanceof TextSelection;
  const isTooltipChildren = this.element.contains(document.activeElement);
  const notHasFocus = !view.hasFocus() && !isTooltipChildren;
  const isReadonly = !view.editable;
  if (notHasFocus || empty || isEmptyTextBlock || isReadonly) return false;
  return true;
};
function tooltipFactory(id) {
  const tooltipSpec = $ctx(
    {},
    `${id}_TOOLTIP_SPEC`
  );
  const tooltipPlugin = $prose((ctx) => {
    const spec = ctx.get(tooltipSpec.key);
    return new Plugin({
      key: new PluginKey(`${id}_TOOLTIP`),
      ...spec
    });
  });
  const result = [tooltipSpec, tooltipPlugin];
  result.key = tooltipSpec.key;
  result.pluginKey = tooltipPlugin.key;
  tooltipSpec.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${id}`
  };
  tooltipPlugin.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${id}`
  };
  return result;
}
export {
  TooltipProvider,
  tooltipFactory
};
//# sourceMappingURL=@milkdown_plugin-tooltip.js.map
