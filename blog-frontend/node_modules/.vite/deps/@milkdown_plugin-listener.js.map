{
  "version": 3,
  "sources": ["../../../../node_modules/@milkdown/plugin-listener/src/index.ts"],
  "sourcesContent": ["import type { Ctx, MilkdownPlugin } from '@milkdown/ctx'\nimport type { Node as ProseNode } from '@milkdown/prose/model'\nimport type { Selection } from '@milkdown/prose/state'\n\nimport {\n  EditorViewReady,\n  InitReady,\n  SerializerReady,\n  prosePluginsCtx,\n  serializerCtx,\n} from '@milkdown/core'\nimport { createSlice } from '@milkdown/ctx'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport debounce from 'lodash.debounce'\n\n/// The dictionary of subscribers of each event.\nexport interface Subscribers {\n  beforeMount: ((ctx: Ctx) => void)[]\n  mounted: ((ctx: Ctx) => void)[]\n  updated: ((ctx: Ctx, doc: ProseNode, prevDoc: ProseNode) => void)[]\n  markdownUpdated: ((\n    ctx: Ctx,\n    markdown: string,\n    prevMarkdown: string\n  ) => void)[]\n  blur: ((ctx: Ctx) => void)[]\n  focus: ((ctx: Ctx) => void)[]\n  destroy: ((ctx: Ctx) => void)[]\n  selectionUpdated: ((\n    ctx: Ctx,\n    selection: Selection,\n    prevSelection: Selection | null\n  ) => void)[]\n}\n\n/// The manager of listeners. It provides methods to subscribe to events.\nexport class ListenerManager {\n  private beforeMountedListeners: Array<(ctx: Ctx) => void> = []\n  private mountedListeners: Array<(ctx: Ctx) => void> = []\n  private updatedListeners: Array<\n    (ctx: Ctx, doc: ProseNode, prevDoc: ProseNode) => void\n  > = []\n  private selectionUpdatedListeners: Array<\n    (ctx: Ctx, selection: Selection, prevDoc: Selection | null) => void\n  > = []\n  private markdownUpdatedListeners: Array<\n    (ctx: Ctx, markdown: string, prevMarkdown: string) => void\n  > = []\n  private blurListeners: Array<(ctx: Ctx) => void> = []\n  private focusListeners: Array<(ctx: Ctx) => void> = []\n  private destroyListeners: Array<(ctx: Ctx) => void> = []\n\n  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.\n  get listeners(): Subscribers {\n    return {\n      beforeMount: this.beforeMountedListeners,\n      mounted: this.mountedListeners,\n      updated: this.updatedListeners,\n      markdownUpdated: this.markdownUpdatedListeners,\n      blur: this.blurListeners,\n      focus: this.focusListeners,\n      destroy: this.destroyListeners,\n      selectionUpdated: this.selectionUpdatedListeners,\n    }\n  }\n\n  /// Subscribe to the beforeMount event.\n  /// This event will be triggered before the editor is mounted.\n  beforeMount = (fn: (ctx: Ctx) => void) => {\n    this.beforeMountedListeners.push(fn)\n    return this\n  }\n\n  /// Subscribe to the mounted event.\n  /// This event will be triggered after the editor is mounted.\n  mounted = (fn: (ctx: Ctx) => void) => {\n    this.mountedListeners.push(fn)\n    return this\n  }\n\n  /// Subscribe to the updated event.\n  /// This event will be triggered after the editor state is updated and **the document is changed**.\n  /// The second parameter is the current document and the third parameter is the previous document.\n  updated = (\n    fn: (ctx: Ctx, doc: ProseNode, prevDoc: ProseNode | null) => void\n  ) => {\n    this.updatedListeners.push(fn)\n    return this\n  }\n\n  /// Subscribe to the markdownUpdated event.\n  /// This event will be triggered after the editor state is updated and **the document is changed**.\n  /// The second parameter is the current markdown and the third parameter is the previous markdown.\n  markdownUpdated(\n    fn: (ctx: Ctx, markdown: string, prevMarkdown: string) => void\n  ) {\n    this.markdownUpdatedListeners.push(fn)\n    return this\n  }\n\n  /// Subscribe to the blur event.\n  /// This event will be triggered when the editor is blurred.\n  blur(fn: (ctx: Ctx) => void) {\n    this.blurListeners.push(fn)\n    return this\n  }\n\n  /// Subscribe to the focus event.\n  /// This event will be triggered when the editor is focused.\n  focus(fn: (ctx: Ctx) => void) {\n    this.focusListeners.push(fn)\n    return this\n  }\n\n  /// Subscribe to the destroy event.\n  /// This event will be triggered before the editor is destroyed.\n  destroy(fn: (ctx: Ctx) => void) {\n    this.destroyListeners.push(fn)\n    return this\n  }\n\n  /// Subscribe to the selectionUpdated event.\n  /// This event will be triggered when the editor selection is updated.\n  selectionUpdated(\n    fn: (\n      ctx: Ctx,\n      selection: Selection,\n      prevSelection: Selection | null\n    ) => void\n  ) {\n    this.selectionUpdatedListeners.push(fn)\n    return this\n  }\n}\n\n/// The ctx key of the listener manager.\n/// You can use `ctx.get(listenerCtx)` to get the [listener manager](#class-listenermanager).\nexport const listenerCtx = createSlice<ListenerManager>(\n  new ListenerManager(),\n  'listener'\n)\n\n/// The plugin key of the listener prosemirror plugin.\nexport const key = new PluginKey('MILKDOWN_LISTENER')\n\n/// The listener plugin.\nexport const listener: MilkdownPlugin = (ctx) => {\n  ctx.inject(listenerCtx, new ListenerManager())\n\n  return async () => {\n    await ctx.wait(InitReady)\n    const listener = ctx.get(listenerCtx)\n    const { listeners } = listener\n\n    listeners.beforeMount.forEach((fn) => fn(ctx))\n\n    await ctx.wait(SerializerReady)\n    const serializer = ctx.get(serializerCtx)\n\n    let prevDoc: ProseNode | null = null\n    let prevMarkdown: string | null = null\n    let prevSelection: Selection | null = null\n\n    const plugin = new Plugin({\n      key,\n      view: () => {\n        return {\n          destroy: () => {\n            listeners.destroy.forEach((fn) => fn(ctx))\n          },\n        }\n      },\n      props: {\n        handleDOMEvents: {\n          focus: () => {\n            listeners.focus.forEach((fn) => fn(ctx))\n            return false\n          },\n          blur: () => {\n            listeners.blur.forEach((fn) => fn(ctx))\n            return false\n          },\n        },\n      },\n      state: {\n        init: (_, instance) => {\n          prevDoc = instance.doc\n          prevMarkdown = serializer(instance.doc)\n        },\n        apply: (tr) => {\n          const currentSelection = tr.selection\n          if (\n            (!prevSelection && currentSelection) ||\n            (prevSelection && !currentSelection.eq(prevSelection))\n          ) {\n            listeners.selectionUpdated.forEach((fn) => {\n              fn(ctx, currentSelection, prevSelection)\n            })\n            prevSelection = currentSelection\n          }\n\n          if (!tr.docChanged || tr.getMeta('addToHistory') === false) return\n\n          const handler = debounce(() => {\n            const { doc } = tr\n            if (listeners.updated.length > 0 && prevDoc && !prevDoc.eq(doc)) {\n              listeners.updated.forEach((fn) => {\n                fn(ctx, doc, prevDoc!)\n              })\n            }\n\n            if (\n              listeners.markdownUpdated.length > 0 &&\n              prevDoc &&\n              !prevDoc.eq(doc)\n            ) {\n              const markdown = serializer(doc)\n              listeners.markdownUpdated.forEach((fn) => {\n                fn(ctx, markdown, prevMarkdown!)\n              })\n              prevMarkdown = markdown\n            }\n\n            prevDoc = doc\n          }, 200)\n\n          return handler()\n        },\n      },\n    })\n    ctx.update(prosePluginsCtx, (x) => x.concat(plugin))\n\n    await ctx.wait(EditorViewReady)\n    listeners.mounted.forEach((fn) => fn(ctx))\n  }\n}\n\nlistener.meta = {\n  package: '@milkdown/plugin-listener',\n  displayName: 'Listener',\n}\n"],
  "mappings": "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",
  "names": ["listener", "debounce"]
}
