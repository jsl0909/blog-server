# Day_10随堂笔记

## 01_面向对象之多态性 [重要]

```java
多态 : 事物的多种形态;  
	在Java中什么是事物 ? class [类],interface[接口]
    何为类的多种形态 ?  人 [类] -> 男[类] 女[类]  , 水杯 [类] -> 玻璃杯 [类] 塑料杯[类]
    多态就是对一类事物进行细分 !
        
多态的本质 : Java中引用数据类型子父类之间/实现类和父接口之间的类型转换问题
    
类型转换问题 : //类型具备特性
	基本数据类型具备类型转换的能力的原因是 : 基本数据类型之间有大小关系 
        [double > float > long > int > short,byte,char]
	基本数据类型 : 
		自动提升 : 大类型变量自动接收小类型的值/变量; double d = 100;
        强制转换 : 小类型变量强制接收大类型的值/变量; int num = (int)13.14;

	引用数据类型现在也想有这样好用的类型转换特性 : 要想办法让Java引用数据类型之间有大小关系 !
        引用数据类型之间想要有大小关系 : 父类/子类 , 父接口/实现类 //前提
    多态 :
		向上转型 : Fu fu = new Zi(); / InterFu fu = new Zi(); //自动的
		向下转型 : Zi zi = (Zi)fu; //强制的

代码实例 :
	//Animal 是父类 ,Dog 是子类
	Animal animal = new Dog(); [正确] //任意一条狗它都是一只动物
	Dog dog = new Animal(); [错误] //任意一只动物他都是一条狗 
	Dog dog = (Dog)animal; [正确] //向下转型的前提 : 对象的本质必须是小类型
```

### 多态的前提条件

```java
1. 必须有继承或者实现关系 [这样类与类之间,类和接口之间才有大小关系]
2. 必须有向上转型和向下转型的代码出现 
    向上转型 : 父引用接收子类对象 -> Fu fu = new Zi();
	向下转型 : 子引用强制接收父引用 -> Zi zi = (Zi)fu; 
3. 第三条件不是必要条件 : 子父类/实现类和父接口之间有方法的重写 [特性 : 动态绑定]
```

### 多态前提下方法的访问特性

```java
多态前提下方法的访问特性 : 动态绑定
```

![image-20240607104411898](谈斌_Day_10随堂笔记.assets/image-20240607104411898.png)

![image-20240607105515713](谈斌_Day_10随堂笔记.assets/image-20240607105515713.png)

### 多态的弊端

```java
多态的弊端 : 父引用不能访问子类的特有成员 !
    
package com.atguigu.c_poly_problem;
/*
    多态的弊端 [继承/实现]:
        父引用不能访问子类的特有成员 !
 */
public class Demo {
    public static void main(String[] args) {
        //以多态的形式创建对象 -> 不推荐的
        Animal animal = new Dog(); //不推荐

        animal.eat();
        //animal.lookHome();


        Dog dog = new Dog(); //推荐的
        dog.eat();
        dog.lookHome();
    }
}
class Animal{
    public void eat(){
        System.out.println("动物吃东西!");
    }
}

class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗吃骨头!");
    }

    public void lookHome(){
        System.out.println("狗看家!");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼!");
    }

    public void catchMouse(){
        System.out.println("猫抓老鼠!");
    }
}
```

### 多态的弊端如何解决

```java
多态的弊端如何解决 : 向下转型
    
public class Demo {
    public static void main(String[] args) {
       //创建子类对象
        Dog dog = new Dog();
        useAnimal(dog);

        Cat cat = new Cat();
        //useAnimal(cat);
    }

    public static void useAnimal(Animal animal){
        animal.eat();

        //想在方法内分别调用子类们的特有行为 --> 直接调用肯定不行
        //解决多态的弊端 : 父引用不能访问子类特有成员的问题 -> 向下转型
        Dog dog = (Dog) animal;
        dog.lookHome();
    }
}    
```

### 向下转型的弊端

```java
向下转型的弊端 : ClassCastException [类型转型异常]
    
异常如何产生 : 把对象转成了和它无关类型的对象 [例如 : 把猫对象转成了狗对象] -> 对象真实类型是什么才能向下转型成什么类型 !
    
向下转型的弊端如何规避 : 在转型之前做类型判断 !  
    利用关键字 : instanceof
    用法 : 引用 instanceof 类型 -> 判断前面引用的真实类型是否是后方类型,返回一个boolean类型的结果    
```

### 多态的真实使用场景

```java
咱们绝对不会以 Fu fu = new Zi()的方式创建对象,因为父引用不能访问子类的特有成员! 要创建对象绝对是优先创建子类对象, 因为子类对象的功能是最多的[子类自己的功能还有父类们公共的功能] !!

1. 把父类型作为方法的形参类型,那么启动方法的方式有 n + 1 种;
2. 把父类型作为容器的元素数据类型,那么容器内可以存储的元素类型是 n + 1 种; 
	Object[] objs = new Object[10]; //此数组种的元素数据类型可以是Java中的任意数据类型
3. 把方法的返回值类型写成父类型,那么方法的结果类型有 n + 1 种;
	public Object get(){
        return 结果; //此方法结果的数据类型可以是任意数据类型
    }
4. 在异常处理环节 : 抛出和捕获父类型异常,那么子类型异常也一并被抛出和捕获 !


n : 此父类型有多少个子类型
1 : 此父类型自己 [有时候没有这个1 : 如果父类型是 抽象类型或者接口类型]
```

## 02_访问权限修饰符 [重要]

```java
访问权限修饰符 :
	public [公共的] > protected [受保护的]> 不写[默认的] > private [私有的]
```

|               | 同一个类中 | 同包不同类 | 不同包有继承关系 | 不同包无关类 |
| :-----------: | :--------: | :--------: | :--------------: | :----------: |
|  **public**   |     √      |     √      |        √         |      √       |
| **protected** |     √      |     √      |        √         |      X       |
|   **不写**    |     √      |     √      |        X         |      X       |
|  **private**  |     √      |     X      |        X         |      X       |

```java
public : 整个模块[Moudle]内都可以访问
protected : 不同包有继承关系时可以访问 [最大权限]   
不写 : 同一个包下能访问 [最大权限]
private : 只能在当前类中使用     
```

## 03_可变参数[重要]

```java
可变参数 : 一种形参的定义格式,当方法的形参中有可变参数时,那么调用方法时可以在可变参数形参位置传入任意个此类型的实参!
    
可变参数的定义格式 :
	//定义方法的位置
	方法名(数据类型...形参名)
```

## 04_代码块[理解]

> 代码块 : {} [大括号既是代码块]
>
> 代码块的作用 : 在代码块的内部写代码

### 局部代码块

```java
局部代码块 : 定义在方法内的大括号
    
局部代码块的作用 : 控制局部变量的生命周期 [缩短]
    
局部代码块此知识点已经不再使用了 ! 为什么 ? 因为现在硬件水平很高,不需要去控制局部变量的生命周期 !    
```

### 构造代码块

```java
构造代码块 : 定义在成员位置的大括号
    
构造代码块的执行时机 :
    1. 每当对象创建时[new],构造代码块执行一次,优先于构造方法执行 [正确]
    2. 每当构造方法执行时,构造代码块执行一次,优先于构造方法执行 [错误]
            
构造代码块何时使用 :
	如果创建一个对象,需要一些前置代码,那么可以把这些前置代码放在构造代码块中! 那么每当对象创建,构造代码块中的前置代码都会执行一次 ! 
    举例 : 对象 -> 皇上 , 构造代码块 -> 宫女太监    
```

### 静态代码块[重要]

```java
静态代码块 : 定义在成员位置且被static修饰的大括号
    
静态代码块执行时机 : 当类第一次加载时执行,执行一次 ! [为类的加载做准备]

当只是访问类中的自定义常量时,类不完全加载,类中的静态代码块不执行 ! [常量的优化机制]   
    
静态代码块何时使用 :
	如果一个类的加载需要一些前置代码,那么可以把这些前置代码放在静态代码块,当这个类第一次被加载时,类中的静态代码块执行一次,而且只执行一次,优先于类中其他所有成员 !
    举例 : 静态代码块比作 "类的驱动"   
```

## 05_内部类

### 成员内部类

```java
成员内部类 : 定义在类成员位置的类 
    
格式 :
	public class Outer{ //外部类
        public class Inner{//成员内部类
            
        }
    }

成员内部类的访问问题 :
    1. 在内部类中访问外部类成员 :
        a. 不同名的成员 : 直接访问
        b. 同名的成员 : 优先访问内部类自己的
            强制访问外部类的成员 : 外部类名.this.成员名称
            
    2. 在外部类中访问内部类成员 : 不能直接访问
            强制访问内部类的成员 : 创建内部类对象
        
    3. 在第三方类中创建外部类对象访问内部类成员 : 不能访问
       在第三方类中访问内部类成员只能创建内部类对象 
        格式 : Outer.Inner inner = new Outer().new Inner(); [重要]
        
    4. 在第三方类中创建内部类对象访问外部类成员 : 不能访问
        
成员内部类的使用场景 :  当一个类只为另一个类服务时,可以把这个类定义在被服务的类的内部 ! [动物 - 心脏]  
```

### 静态成员内部类

```java
成员内部类 : 定义在类成员位置且被static修饰的类 
    
格式 :
	public class Outer{ //外部类
        public static class Inner{//静态成员内部类
            
        }
    }
    1. 在静态成员内部类中访问外部类成员 :
        a.外部类的非静态成员  : 不能直接访问 [static只能访问静态]
            解决方案 : 创建外部类对象即可
        b.外部类的静态成员 :
            同名 :  外部类类名.成员名称
            不同名 : 直接访问


    2. 在外部类中访问内部类成员 : 不能直接访问
            强制访问内部类的成员 : 创建内部类对象

    3. 在第三方类中创建外部类对象访问内部类成员 : 不能访问
       在第三方类中访问静态内部类成员只能创建静态成员内部类对象
        格式 : Outer.Inner inner = new Outer.Inner(); [重要] -> 静态成员内部类对象

    4. 在第三方类中创建内部类对象访问外部类成员 : 不能访问
```

### 局部内部类

```java
局部内部类 : 定义在方法内的类
    
格式 :
	public class Outer{ //外部类
        //定义一个方法
        方法声明(形参列表){
            
            //在这里就不能使用局部内部类
            
            class Inner{//局部内部类
            
        	}
            
            //在这里可以使用局部内部类
        }
    }

局部内部类只能在定义的方法内部使用,出了方法就用不了! 
注意 : 局部位置有先后关系,所以在方法内使用方法内的局部变量时需要在定义完局部内部类的后方使用    
```

### 匿名内部类[重要]

```java
匿名内部类 : 最主要的作用是方便的去使用接口 --> 简化项目结构
    
匿名内部类的格式 :
	//匿名内部类对象
	接口名 对象名 = new 接口名(){
        //重写接口中的所有抽象方法
    };

代码演示 :
	//匿名内部类对象
    new InterFu(){
        //重写父接口中所有的抽象方法
        @Override
        public void show() {
            System.out.println("匿名内部类重写的show方法");
        }
    }
	//匿名内部类
    {
        //重写父接口中所有的抽象方法
        @Override
        public void show() {
            System.out.println("匿名内部类重写的show方法");
        }
    }

----------------------------------
匿名内部类还可以简化 普通父类和抽象父类 子类的书写 !!    
```

### 匿名内部类的结构分析

![image-20240607163730718](谈斌_Day_10随堂笔记.assets/image-20240607163730718.png)

### 匿名内部类对象调用方法的步骤

![image-20240607164050098](谈斌_Day_10随堂笔记.assets/image-20240607164050098.png)