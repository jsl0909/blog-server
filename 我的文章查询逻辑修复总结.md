# 我的文章查询逻辑修复总结

## 问题描述

用户反馈"我的文章"功能仍然显示所有已发布的文章，而不是用户自己的所有文章（包括未发布的）。

## 问题分析

### 根本原因
之前的查询逻辑有误：
```typescript
// 错误的逻辑
const where: any = {
  OR: [
    { status: 'PUBLISHED' }, // 已发布的文章
    ...(userId ? [{ authorId: userId }] : []) // 用户自己的文章
  ]
};
```

这个逻辑意味着：显示所有已发布的文章 OR 用户自己的文章
结果：会显示所有已发布的文章（包括其他用户的）

### 正确的需求
- **全部文章**：只显示已发布的文章
- **我的文章**：只显示用户自己的所有文章（包括未发布的）

## 修复方案

### 1. 修改查询逻辑

**修复前：**
```typescript
// 构建查询条件：已发布的文章 + 用户自己的文章（包括未发布的）
const where: any = {
  OR: [
    { status: 'PUBLISHED' }, // 已发布的文章
    ...(userId ? [{ authorId: userId }] : []) // 用户自己的文章（包括未发布的）
  ]
};
```

**修复后：**
```typescript
// 构建查询条件
let where: any = {};

if (myPosts && userId) {
  // 查看我的文章：只显示用户自己的所有文章（包括未发布的）
  where.authorId = userId;
} else {
  // 查看全部文章：只显示已发布的文章
  where.status = 'PUBLISHED';
}
```

### 2. 添加myPosts参数

**后端服务：**
```typescript
async getPublishedPosts(options: {
  page: number;
  limit: number;
  category?: string;
  tag?: string;
  search?: string;
  userId?: number;
  myPosts?: boolean; // 新增：是否只查看我的文章
}) {
  const { page, limit, category, tag, search, userId, myPosts } = options;
  // ...
}
```

**后端控制器：**
```typescript
async getPosts(@Query() query: any, @Req() req) {
  const { page = 1, limit = 10, category, tag, search, myPosts } = query;
  const userId = req.user?.id;
  
  return this.blogService.getPublishedPosts({
    page: Number(page),
    limit: Number(limit),
    category,
    tag,
    search,
    userId,
    myPosts: myPosts === 'true' // 转换字符串为布尔值
  });
}
```

**前端调用：**
```typescript
const loadPosts = async () => {
  const params: any = {
    page: currentPage.value,
    limit: 10
  };
  
  // 如果显示我的文章，添加相关参数
  if (showMyPosts.value && authStore.isAuthenticated) {
    params.userId = authStore.user?.id;
    params.myPosts = 'true'; // 传递字符串参数
  }
  
  const data = await blogApi.getPosts(params);
  // ...
};
```

**前端API类型：**
```typescript
getPosts: (params?: { 
  page?: number; 
  limit?: number; 
  category?: string; 
  tag?: string; 
  search?: string; 
  userId?: number; 
  myPosts?: string; // 新增参数
}): Promise<PostsResponse> =>
  api.get('/api/blog/posts', { params }),
```

## 技术实现细节

### 1. 查询条件逻辑
```typescript
if (myPosts && userId) {
  // 我的文章：authorId = userId（包括所有状态）
  where.authorId = userId;
} else {
  // 全部文章：status = 'PUBLISHED'（只显示已发布）
  where.status = 'PUBLISHED';
}
```

### 2. 参数传递流程
1. **前端**：`showMyPosts.value` → `params.myPosts = 'true'`
2. **API调用**：`blogApi.getPosts(params)`
3. **后端控制器**：`myPosts: myPosts === 'true'`
4. **后端服务**：根据 `myPosts` 参数决定查询逻辑

### 3. 调试信息
```typescript
console.log('getPosts - req.user:', req.user);
console.log('getPosts - userId:', userId);
console.log('getPosts - query:', query);
console.log('getPosts - myPosts:', myPosts);
```

## 功能特点

### 1. 全部文章模式
- **查询条件**：`status = 'PUBLISHED'`
- **显示内容**：所有已发布的文章
- **适用场景**：首页、文章列表页

### 2. 我的文章模式
- **查询条件**：`authorId = userId`
- **显示内容**：用户自己的所有文章（包括草稿、已发布、已归档）
- **适用场景**：个人文章管理

### 3. 权限控制
- **游客**：只能看到已发布的文章
- **已登录用户**：可以看到自己的所有文章
- **管理员**：可以看到所有文章（通过管理后台）

## 测试场景

### 1. 全部文章
- **请求参数**：无 `myPosts` 参数
- **查询条件**：`status = 'PUBLISHED'`
- **预期结果**：显示所有已发布的文章

### 2. 我的文章
- **请求参数**：`myPosts = 'true'` 且 `userId` 存在
- **查询条件**：`authorId = userId`
- **预期结果**：只显示用户自己的文章（包括未发布的）

### 3. 游客访问
- **请求参数**：无 `userId`
- **查询条件**：`status = 'PUBLISHED'`
- **预期结果**：只显示已发布的文章

## 总结

通过修复查询逻辑，现在"我的文章"功能可以正确工作：

1. **明确区分两种模式** - 全部文章 vs 我的文章
2. **正确的查询条件** - 根据模式使用不同的查询逻辑
3. **完整的参数传递** - 从前端到后端的完整参数链路
4. **清晰的权限控制** - 确保用户只能看到应该看到的内容

这个修复确保了用户能够正确查看和管理自己的文章，同时保持了系统的安全性。 